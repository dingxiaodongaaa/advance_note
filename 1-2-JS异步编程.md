# JS异步编程

## JS采用单线程模式的原因

最早的js就是运行在浏览器端的脚本语言，目的就是为了实现页面的动态交互，实现页面交互的核心就是DOM操作，这就决定了它必须使用单线程模式，否则就会出现很复杂的线程同步问题。

为什么呢？假如说js是多线程的，也就是操作DOM编程了多线程并发执行，当一个线程对DOM元素做了修改，而同事的另一个并发线程对同一个DOM元素也做出了修改，最终浏览器是听谁的呢？显然很不合理。

单线程决定了在js执行环境中负责执行代码的线程只有一个，如果有多个任务，就只能排队一个任务一个任务的执行。那么问题又来了，如果有一个任务是非常耗费时间的，那后面的任务就只能在队列中等着，出现假死的情况。为了解决这个问题，js将任务的执行模式分成了**同步模式**和**异步模式**

## 内容概要

- 同步模式和异步模式
- 事件循环与消息队列
- 异步编程的几种方式
- `Promise`异步方案、宏任务/微任务队列
- `Generator`异步方案、`Async/Await`语法糖

## 同步模式

程序阻塞执行，只有上一个任务执行完成才回去执行后面的任务。

## 异步模式 

非堵塞执行程序，后面的任务不会等待上一个任务执行结束才执行，而是当上一个任务开启之后就会立即去执行后续的任务。而单线程的js是如何处理上一个任务的呢？一般是通过回调函数的方式定义后续的程序执行方式，具体如何请往下看。

异步模式给单线程的js提供了一种解决大量耗时任务占用线程时间过长的思路。

大家都知道用回调函数的方式，会造成回调的层层嵌套，即回调地狱，导致代码非常的难以维护，js也提供了很多解决回调地狱的方法。

下面是一个异步程序在浏览器中执行的过程案例：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200517215815469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbmd4dWFuMTUwOQ==,size_16,color_FFFFFF,t_70)

首先大体了解一下这块代码，代码中首尾两个console.log,中间显示一个延时器函数，然后接着又是一个延时器函数，在第二个延时器函数里面又嵌套了一个延时器。下面来解释这块代码是如何执行的。

1. 首先，将一个匿名的函数调用压入调用栈（Call stack）中；
2. 对于`console.log()`这种同步执行的api，直接将其压入调用栈，紧接着执行完之后弹出栈，并在执行的过程中在控制台输出‘global begin’;
3. 然后就会执行到第一个延时器函数，首先还是先将`setTimeout`压入调用栈，这个函数内部的api是以异步的方式执行的，调用函数里面的异步api就会在Web APIs中添加一个倒计时器，并把这个倒计时器放到一边，这个倒计时器是在一个单独的专门执行异步线程中，在这个倒计时器放进去之后就开始倒计时了，而且他会被扔在一旁并不影响js线程的正常执行。
4. 当第一个延时器被放到另一个计时器线程中之后，程序会立即继续向下执行，开始第二个延时器的执行，和第一个延时器一样，在Web APIs中添加一个倒计时器，程序继续向下执行。
5. 将`console.log`压入调用栈，在控制台打印‘global end’。
6. 当执行完最后一步`console.log`，调用栈中就会空闲，当Web APIs中的倒计时器执行倒计时完成的时候，就会将回调函数添加到消息队列中（Queue），事件环（Event loop）会同时的监听调用栈和消息队列，当调用栈空闲并且消息队列中又待处理的消息的时候，事件环就会将消息队列中的第一个消息交给调用栈去处理。这里的第一个延时器显然要晚于第二个延时器，所以第二个延时器先倒计时完之后先将第二个定时器的回调函数添加到消息队列中等待执行，等到事件环监听到调用栈空闲的时候就会将消息队列中的第一条消息交给调用栈，也就是第二个定时器的回调开始执行，打印‘time2 invoke’。
7. 和第二个延时器一样，第一个延时器的回调也会添加一个延时器到专门倒计时的线程中倒计时。
8. 当第一个延时器倒计时完成，进行和第二个延时器相同的操作之后打印‘teimer1 invoke’.
9. 然后第二个延时器中的延时器也会进行相同的操作之后打印‘inner invoke’。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200517223119142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbmd4dWFuMTUwOQ==,size_16,color_FFFFFF,t_70)

这里有一个疑惑就是，为什么会存在除了js线程之外的另一个线程。

其实js确实是单线程的，但是浏览器是多线程的，而且通过js调用的某些浏览器的api也不是单线程的，例如延时器api，浏览器里面会有一个单独用于倒计时的线程，专门用来倒计时，等到倒计时完成的时候将倒计时器的回调函数添加到消息队列。 

再次强调一下，js就是单线程，它的程序只能在js那一个线程中执行，只不过对于浏览器的一些用js调用的api会在浏览器中单独的一个线程单独执行。

我们说的同步模式和异步模式也是相对于运行环境提供的API而言的。
