# 面试题收集

# 编码

## 1说出并解释下列代码的输出结果：

~~~JavaScript
function Foo() {
  getName = function () {
    console.log(1);
  };
  return this;
}
Foo.getName = function () {
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {
  console.log(4);
};
function getName() {
  console.log(5);
}
Foo.getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
~~~

参考答案

1、    Foo.getName();

    调用Foo的静态方法，所以，打印2

2、    Foo().getName();

    Foo()就是普通函数调用，返回的this是window，后面调用window.getName()
    而window下的getName在Foo()中调用getName被重新赋值,所以,打印1

3、   getName();

    在执行过Foo().getName()的基础上，所以getName=function(){console.log(1)},所以,打印1，[如果getName()放在Foo().getName()上执行打印结果为4]

4、  new Foo.getName();

    构造器私有属性的getName(),所以,打印2

5、   new Foo().getName();

    原型上的getName()，打印3

6、   new new Foo().getName() 

首先new  Foo()得到一个空对象{}

第二步向空对象中添加一个属性getName，值为一个函数

第三步new {}.getName()   

等价于 var bar = new (new Foo().getName)();  console.log(bar)
         先new Foo得到的实例对象上的getName方法，再将这个原型上getName方法当做构造函数继续new ，所以执行原型上的方法,打印3

## 2.写出它们结果打印的先后顺序，并分析出原因

```js
function Foo() {
  for (var i = 0; i < 5; i++) {
    setTimeout(function timer() {
      console.log(i);
    }, 1000);
  }
  console.log(i);
}
Foo();
```

解析：函数Foo中有一个for循环，for里面是一个定时器，for循环了5次，那么定时器也将设定5个。setTimeout被放在了队列的数据结构中（for循环），等待上下文的代码运行后才会去执行定时器，那么此时运行定时器，变量i已经变成了5（5个定时器的i都是5），所以输出的是5 5 5 5 5 5。



## 3.写出它们结果打印的先后顺序，并分析出原因

```js
function Foo() {
  for (var i = 0; i < 5; i++) {
    (function (i) {
      setTimeout(function timerr() {
        console.log(i);
      }, 1000);
    })(i);
  }
  console.log(i);
}
Foo();
```

解析：函数Foo中有一个for循环，for里面是一个IIFE函数（自执行函数），这个函数里面有一个定时器，for循环5次，那么定时器也将生成5个。由于IIFE声明函数的同时会立即调用函数一次，所以形成了一个私有作用域，变量i被独立了起来，每个定时器输出的i就会都不相同，所以输出的是5 0 1 2 3 4。



## 4.写出它们结果打印的先后顺序，并分析出原因

```js
setTimeout(function () {
  console.log("BBBB");
}, 1000);
console.log("CCCC");
setTimeout(function () {
  console.log("DDDD");
}, 0);
```

解析：setTimeout是在指定的时间后执行一段代码，所以先执行console.log("CCCC")，回过头再看这两个setTimeout，第一个是1000毫秒后执行，而第二个是0毫秒后执行，所以先打印出来的是console.log("DDDD")，1000毫秒后打印console.log("BBBB")。最后的输出顺序是"CCCC"  "DDDD"  "BBBB"。



## 5.写出它们结果打印的先后顺序，并分析出原因

```js
setTimeout(function () {
  console.log("BBBB");
}, 1000);
const start = new Date();
while (new Date() - start < 3000) {}
console.log("CCCC");
setTimeout(function () {
  console.log("DDDD");
}, 0);
```

解析：setTimeout是在指定的时间后执行一段代码，执行下面的const start = new Date()。new Date()是实时的时间戳，所以执行这一步的时候，start被赋予的是当前的时间。接下来是while，while循环的执行条件是new Date() - start < 3000，前面说过new Date()是实时的时间戳，所以是一直在增加的，当3000毫秒以后，while执行结束，运行下面的console.log("CCCC")。之后执行两个setTimeout，因为while循环已经进行了3000毫秒了，所以第一个setTimeout已经结束了定时，所以会先执行console.log("BBBB")，然后执行第二个定时器里面的console.log("DDDD")。最后的输出顺序是"CCCC"  "BBBB"  "DDDD"。



## 6.写出打印结果，并分析出原因

```js
var a = 10;
var obj = {
  a: 100,
  pro: {
    getPro: () => {
      console.log(this.a);
    },
  },
};
obj.pro.getPro();
```

解析：首先，全局里变量a的值是10。obj对象里面有两个key分别是a和pro，a的值是100，pro则是一个对象，pro里面的getPro是一个箭头函数，箭头函数里面执行打印this.a。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this，所以这里的this指向window，打印出来的结果是10。



## 7.写出打印结果，并分析出原因

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };
console.log(a.x);
console.log(b.x);
```

解析：首先，a是一个对象，里面只有一个key为n，n的值是1。b = a，那么b指向的对象跟a指向的对象是同一个对象。a.x = a = { n: 2 }，这里面的.的运算优先级要大于=的运算优先级，所以a.x先进行运算，a对象当中多出了一个key为x，接下来运算=，赋值运算是从右向左进行的，所以会先给a对象重新赋值，a对象变成了{ n: 2 }，a.x = a就是a.x = { n: 2 }。运算完毕以后，我们再来看a跟b这两个对象，a现在是{ n: 2 }，b现在是{ n: 1，x: { n: 2 } }。所以最后打印出来的结果是undefined ｛n：2｝。

## 8.写出打印结果，并分析出原因

```js
var length = 10;
function fn() {
  console.log(this.length);
}
 
var obj = {
  length: 5,
  method: function(fn) {
    fn();
    arguments[0]();
  }
};
 
obj.method(fn, 1);  
```

解析：首先，我们在全局定义了一个变量length、一个对象obj和一个函数fn，length赋值为10。接下来是fn函数，输出this.length。对象obj中，obj.length是5，obj.method是一个函数。method函数里面的形参也是一个函数，这个函数里面调用了fn函数，arguments是一个伪数组，代表method函数实际接收到的参数列表，所以arguments[0] ()就代表了调用arguments里的第一项。obj.method(fn, 1)代表的就是调用obj当中的method函数，并且传递了两个参数，fn和1。

分析完了代码的含义，我们来看输出结果。method函数当中调用的fn函数是全局当中的函数，所以this指向的是window，this.length就是10。上面说了，arguments[0] ()代表的是调用arguments里面的第一项，也就是传参进来的fn，所以这个this指向的是arguments，method函数接收的参数是两个，所以arguments.length就是2。最后的输出结果就是  10  2

## 9.写出打印结果，并分析出原因

```js
function a(xx){
  this.x = xx;
  return this;
};
var x = a(5);
var y = a(6);

console.log(x.x);
console.log(y.x);
```

解析：首先，我们在全局定义了一个变量x、一个变量y和一个函数a，函数a当中的this.x等于接收到的参数，返回this，这里要注意，返回的不是this.x，而是this。接下来我们给x赋值，值为a(5)，又给y进行赋值，值为a(6)。最后，我们输出x.x，y.x。

分析完代码的含义，我们来看输出结果。a函数传了一个参数5，那么this.x就被赋值为了5，函数a的this指向的是window，也就是window.x = 5。上面我们说过，这个函数返回的是this，也就是this指向的window，x = a(5)就相当于window.x = window，此时的x被赋值为了window。下面又执行了y = a(6)，也就是说，x的值再次发生了改变，边为了6，y则被赋值为了window。console.log(x.x)就相当于console.log(6.x)，输出的自然是undefined。console.log(y.x)，输出的相当于是console.log(window.x)，得到的值自然是6。最后输出的结果为  undefined   6

10.阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，小伙伴们，加油哦！
-------------
```js
1 console.log("AAAA");
2 setTimeout(() => console.log("BBBB"), 1000);
3 const start = new Date();
4 while (new Date() - start < 3000) {}
5 console.log("CCCC");
6 setTimeout(() => console.log("DDDD"), 0);
7 new Promise((resolve, reject) => {
8   console.log("EEEE");
9   foo.bar(100);
10 })
11 .then(() => console.log("FFFF"))
12 .then(() => console.log("GGGG"))
13 .catch(() => console.log("HHHH"));
14 console.log("IIII");
```

**答案：**

浏览器下 输出结果的先后顺序是

```js
AAAA
CCCC
EEEE
IIII
HHHH
BBBB
DDDD
```

答案解析：这道题考察重点是  js异步执行 宏任务 微任务。



一开始代码执行，输出`AAAA`.  1

第二行代码开启一个计时器t1(一个称呼)，这是一个异步任务且是宏任务，需要等到1秒后提交。

第四行是个while语句，需要等待3秒后才能执行下面的代码,这里有个问题，就是3秒后上一个计时器t1的提交时间已经过了，但是线程上的任务还没有执行结束，所以暂时不能打印结果，所以它排在宏任务的最前面了。

第五行又输出`CCCC`

第六行又开启一个计时器t2（称呼），它提交的时间是0秒（其实每个浏览器器有默认最小时间的，暂时忽略），但是之前的t1任务还没有执行，还在等待，所以t2就排在t1的后面。（t2排在t1后面的原因是while造成的）都还需要等待，因为线程上的任务还没执行完毕。

第七行`new Promise`将执行promise函数，它参数是一个回调函数，这个回调函数内的代码是同步的，它的异步核心在于resolve和reject，同时这个异步任务在任务队列中属于微任务，是优先于宏任务执行的，(不管宏任务有多急，反正我是VIP)。所以先直接打印输出同步代码`EEEE`。第九行中的代码是个不存在的对象，这个错误要抛给reject这个状态，也就是catch去处理，但是它是异步的且是微任务，只有等到线程上的任务执行完毕，立马执行它，不管宏任务（计时器，ajax等）等待多久了。

第十四行，这是线程上的最后一个任务，打印输出	`IIII`

我们先找出线程上的同步代码，将结果依次排列出来：AAAA  CCCC  EEEE IIII

然后我们再找出所有异步任务中的微任务 把结果打印出来  HHHH

最后我们再找出异步中的所有宏任务，这里t1排在前面t2排在后面（这个原因是while造成的），输出结果顺序是 BBBB DDDD

所以综上 结果是  AAAA  CCCC  EEEE  IIII  HHHH BBBB DDDD 

11.阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，小伙伴们，加油哦！
-------------

```js
new Promise(function (resolve, reject) {
  console.log("AAAA");
  resolve();
})
  .then(function () {
    new Promise(function (resolve, reject) {
      console.log("BBBB");
      resolve();
    })
      .then(function () {
        console.log("CCCC");
      })
      .then(function () {
        new Promise(function (resolve, reject) {
          console.log("DDDD");
          resolve();
        })
          .then(function () {
            console.log("EEEE");
          })
          .then(function () {
            console.log("FFFF");
          });
        console.log("GGGG");
      });
    console.log("HHHH");
  })
  .then(function () {
    console.log("IIII");
  });

new Promise(function (resolve, reject) {
  console.log("JJJJ");
  resolve();
})
  .then(function () {
    console.log("KKKK");
  })
  .then(function () {
    console.log("LLLL");
  });
```

解析：首先，我们来看最外层的两个new Promise，里面的同步语句会先执行，所以最先打印出来的是AAAA和JJJJ。

因为每个Promise都会产生一个微任务，所以最外层的两个Promise的第一个then会进入到第一轮的微任务当中，下面我们来单独看这两个then。第一个Promise的第一个then里面又new了一个新的Promise，这个新的Promise产生一个微任务，本轮的微任务已经在执行当中了，所以这个微任务会被排到下一个微任务队列的第一位，还是先执行里面的同步语句，打印BBBB和HHHH，之后运行第二个Promise的第一个then，打印KKKK。

第一轮微任务执行完毕，开始第二轮微任务，先执行第三个Promise的第一个then，打印CCCC，继续执行第一个Promise的第二个then，打印IIII，最后执行第二个Promise的第二个then，打印LLLL。

第三轮微任务开始，执行第三个Promise的第二个then，这个then里面又new了一个新的Promise，同理，新的Promise（第四个）产生的微任务放入下一轮第一个执行，此时执行同步语句，打印DDDD和GGGG。

第四轮微任务开始执行第四个Promise的第一个then，打印EEEE。

第五轮微任务开始执行第四个Promise的第二个then，打印FFFF。

综上，我们最后得到的结果就是：

AAAA
JJJJ
BBBB
HHHH
KKKK
CCCC
IIII
LLLL
DDDD
GGGG
EEEE
FFFF

## 12.阅读下面代码，分析执行结果，并说明具体原因。

问题 1

```js
async function t1() {
  let a = await "lagou";
  console.log(a);
}
t1();
```

问题解析

`await`是一个表达式，如果后面不是一个 `promise` 对象，就直接返回对应的值。

所以问题 1 可以理解为

```js
async function t1() {
  let a = "lagou";
  console.log(a); //lagou
}
t1();
```

## 13.阅读下面代码，分析执行结果，并说明具体原因

```js
async function t2() {
  let a = await new Promise((resolve) => {});
  console.log(a); //
}
t2();
```

问题解析

`await`后面如果跟一个 `promise` 对象，`await` 将等待这个 `promise` 对象的 `resolve` 状态的值 `value`，且将这个值返回给前面的变量，此时的 `promise` 对象的状态是一个 `pending` 状态，没有 `resolve` 状态值，所以什么也打印不了。

## 14.阅读下面代码，分析执行结果，并说明具体原因

```js
async function t3() {
  let a = await new Promise((resolve) => {
    resolve();
  });
  console.log(a); //undefined
}
t3();
```

问题解析

`await`后面如果跟一个 `promise` 对象，`await` 将等待这个 `promise` 对象的 `resolve` 状态的值 `value`，且将这个值返回给前面的变量，此时的 `promise` 对象的状态是一个 `resolve` 状态，但是它的状态值是` undefined`，所以打印出 `undefined`。

## 15.阅读下面代码，分析执行结果，并说明具体原因

```js
async function t4() {
  let a = await new Promise((resolve) => {
    resolve("hello");
  });
  console.log(a); //hello
}
t4();
```

问题解析

`await`后面如果跟一个 `promise` 对象，`await` 将等待这个` promise` 对象的` resolve` 状态的值，且将这个值返回给前面的变量，此时的` promise` 对象的状态是一个 `resolve` 状态，它的状态值是 `hello`，所以打印出 `hello`。

## 16.阅读下面代码，分析执行结果，并说明具体原因

```js
async function t5() {
  let a = await new Promise((resolve) => {
    resolve("hello");
  }).then(() => {
    return "lala";
  });
  console.log(a); //lala
}
t5();
```

问题解析

`await`后面如果跟一个` promise` 对象，`await` 将等待这个 `promise` 对象的 `resolve` 状态的值，且将这个值返回给前面的变量，此时的 `promise` 对象的状态是一个 `resolve` 状态，它的状态值是 `hello`，紧接着后面又执行了一个 `then` 方法，`then` 方法又会返回一个全新的 `promise` 对象，且这个 `then` 方法中的返回值会作为这个全新的 `promise` 中 `resolve` 的值，所以最终的结果是 `lala`。

## 17.阅读下面代码，分析执行结果，并说明具体原因

```js
async function t6() {
  let a = await fn().then((res) => {
    return res;
  });
  console.log(a); //undefined
}
async function fn() {
  await new Promise((resolve) => {
    resolve("lagou");
  });
}
t6();
```

问题解析

`async`函数执行返回一个`promise`对象,且`async`函数内部的返回值会当作这个 `promise` 对象 `resolve` 状态的值

```js
async function fn() {
  return "la";
}
var p = fn();
console.log(p); //Promise {<resolved>: "la"}
//__proto__: Promise
//[[PromiseStatus]]: "resolved"
//[[PromiseValue]]: "la"
```

首先考虑 `fn()` 执行返回一个` promise` 对象，因为 `fn `执行没有返回值，所以这个 `promise` 对象的状态 `resolve` 的值是 `undefined`，且将这个 `undefined` 当作下一个 `then` 中回调函数的参数，所以打印的结果是 `undefined`

## 18.阅读下面代码，分析执行结果，并说明具体原因

```js
async function t7() {
  let a = await fn().then((res) => {
    return res;
  });
  console.log(a);
}
async function fn() {
  await new Promise((resolve) => {
    resolve("lagou");
  });
  return "lala";
}
t7();
```

问题解析

首先考虑 `fn()` 执行返回一个 `promise` 对象，因为`fn()`执行有返回值` lala`，所以这个 `promise` 对象的状态 `resolve` 的值是 `lala`，且将这个 `lala` 当作下一个 `then` 中回调函数的参数，所以打印的结果是 `lala`。

## 19.什么是防抖和节流，他们的应用场景有哪些

防抖 (debounce)

防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。

想要了解一个概念，必先了解概念所应用的场景。在 JS 这个世界中，有哪些防抖的场景呢

1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
2. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖
3. 文本编辑器实时保存，当无任何更改操作一秒后进行保存

代码如下，可以看出来**防抖重在清零 `clearTimeout(timer)`**

```js
function debounce (f, wait) {
  let timer
  return (...args) => {
    clearTimeout(timer)
    timer = setTimeout(() => {
      f(...args)
    }, wait)
  }
}
```

节流 (throttle)

节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。

1. `scroll` 事件，每隔一秒计算一次位置信息等
2. 浏览器播放事件，每个一秒计算一次进度信息等
3. input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)

代码如下，可以看出来**节流重在加锁 `timer=timeout`**

```js
function throttle (f, wait) {
  let timer
  return (...args) => {
    if (timer) { return }
    timer = setTimeout(() => {
      f(...args)
      timer = null
    }, wait)
  }
}
```

总结 (简要答案)

- 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。**代码实现重在清零 `clearTimeout`**。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。
- 节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。**代码实现重在开锁关锁 `timer=timeout; timer=null`**。节流可以比作过红绿灯，每等一个红灯时间就可以过一批

# css

## 20.如何实现一个元素的水平垂直居中

提供一个较少提过的方法，使用 `grid`，它是做二维布局的，但是只有一个子元素时，一维布局与二维布局就一样了。结合 `justify-content`/`justify-items` 和 `align-content/align-items` 就有四种方案

```css
.container {
  display: grid;
  justify-content: center;
  align-content: center;
}
.container {
  display: grid;
  justify-content: center;
  align-items: center;
}
.container {
  display: grid;
  justify-items: center;
  align-content: center;
}
.container {
  display: grid;
  justify-items: center;
  align-items: center;
}
```

# 逻辑

## 21.写一个js函数，实现对一个数字每3位加一个逗号，如输入100000， 输出100,000（不考虑负数，小数）—百度前端面试题

![img](medias/v2-5b817921880f456a54a084317ae6c364_720w.jpg)

解题思路

本题是js实现number.toLocaleString()方法，面试题做了简化不考虑负数小数，此题主要是考数据类型及字符串操作，答案不唯一。

按现实思路解题，现实中添加千位分隔符是从后到前，每3位添加逗号，所以这里输入数据转换成字符串后，利用slice方法的输入负数参数从后取的特点，从后取三位数字保存在数组中，并把取剩后的数据递归重复取值，直到数据不足3位，把剩下一起存入数组中。

这时数组中按顺序保存从后到前的分割数据。实例中数组是[‘789’,’456’,’123’]。通过reverse方法倒叙输出，并通过join方法添加逗号。

## 22.给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题

![img](medias/v2-d8136dca742eb7560c23d1a39e99e86b_720w.jpg)

![img](medias/v2-291f6f8dcd093229bb7d0a9102c826dc_720w.jpg)

解题思路

这题的要点就是无重复字符的理解。首先字符串内字符位置是固定的，我们要采用顺序循环的方式解题，然后就是理解无重复字符的含义，把当前字符串分割，每个小分割内不能出现重复的字符。也就是说分割的字符串是不会互相叠加重复的，每当该段分割的下一个字符与该段分割内字符相同，当即重新开始分割字符。

所以解题时需要一个存储当前分割片段的对象，用来比较下一个字符。并取这个分割片段的长度，与每个分割片段的最大长度比较即可。本题主要考的是题面的理解，以及字符串方法的运用，需要熟练地运用才能快速解题。

## 23.实现超出整数存储范围的两个大正整数相加—腾讯前端面试题

![img](v2-6a8a37d7f089fe690e70177c6acda6f5_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-e9c697d81ad9da8e01b5de0f3dc2f4b0_720w.jpg)

解题思路

首先了解超出存储范围的大数字概念，每种数据类型可存储数据量都是存在范围的

数字类型的范围：

Number.MAX_VALUE = 1.7976931348623157e+308

Number.MIN_VALUE = 5e-324

整数类型的范围：-2-53-253

当超出这个范围，为了避免数据丢失，就要采用其他手段进行运算。在参考答案中，运用数组的方式解决这个问题。首先两个大整数要存储在数组中，要先保证位数对其，我们比较字符串长度把低位数的大整数字符串前面添加相应的0占位， 并逆排序。创建一个新的数组保存运算结果，将两个大整数按从后到前的顺序进行相加减，这里注意进位。把得到的数组反转到正常顺序即可。

## 24.任意二维数组的全排列组合—阿里巴巴前端面试题

![img](medias/v2-b773498514ef9a9cd8ecb195a024c3bd_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-253239f9888feb13a611e6f7f18ddc81_720w.jpg)

解题思路

本题做法不唯一，这里采用了把多项数组逐步两两相乘的方式，第一次先取二维数组前两项组合，把组合的结果在与第三项组合以此类推。这种递归做法简单易懂，把复杂的多项问题简化成两项问题的逐渐递增

## 25.公司最近新研发了一种产品，共生产了n件。有m个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题

![img](medias/v2-e73ad87054ead9b430669cfc42bfb431_720w.jpg)

- **解题思路**

本题是京东的业务演变题，首先要理清思路。本题中，固定出价，以及出价低于产品的顾客会被拒绝购买是解题核心。

条件中已知产品总个数，顾客出价。这里有个小陷阱，会出现N<M供不应求的情况，要特殊考虑。依据题目，我们首先需要对顾客出价排序，这里按升序排列。当供不应求出现时，我们截取出价高的顾客。然后把每个顾客的出价当做最终售价循环，得出最大化利润下的售价。

## 26.计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题

![img](medias/v2-188d09407b1c114796c6d94570e5b665_720w.jpg)

![img](medias/v2-eb1d3cf308421e73a31f0a60abdd8dc1_720w.jpg)

- **解题思路**

计算出全部字符出现次数，并留下最大的。首先利用filter（）与indexOf()的方法连用字符串去重，再将得到的作为索引，利用split()分割字符串，得到字符出现次数，比较得出结果。

## 27.请编写一个 JavaScript 凼数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题

![img](medias/v2-e169a184ba081af3d44347f5089e00ea_720w.jpg)

- **解题思路**

淘宝这道题是很常用的场景题，这里需要处理好分段次序，首先把？分离，然后按&分割最后按=分割，主要考察字符串的函数运用以及对象的创建。

## 28**如果给定的字符串是回文，返回true，反之，返回false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。—网易前端面试题**

![img](medias/v2-af83f7dd839aa7bd1182950912376b66_720w.jpg)

- **解题思路**

去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。

## 29**确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题**

![img](medias/v2-f721848def1ed04cc4635deec90954e1_720w.jpg)

- **解题思路**

1. 字符串转化成小写；
2. 分割成字符串数组；
3. 新组合字符串元素=首字母转大写+其余小写。

## 30.写 React/Vue 项目时为什么要在组件中写 key，其作用是什么？

key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。

vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。可以先了解一下 diff 算法。

在交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。



## 31.介绍下深度优先遍历和广度优先遍历，如何实现？

深度优先遍历（DFS）

深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。

简单的说，DFS 就是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。

DFS 可以产生相应图的拓扑排序表，利用拓扑排序表可以解决很多问题，例如最大路径问题。一般用堆数据结构来辅助实现 DFS 算法。

注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。

步骤：

访问顶点 v；

依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；

若此时途中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到所有顶点均被访问过为止。

```js
Graph.prototype.dfs = function() {
   var marked = []
   for (var i=0; i
       if (!marked[this.vertices[i]]) {
           dfsVisit(this.vertices[i])
       }
   }
   function dfsVisit(u) {
       let edges = this.edges
       marked[u] = true
       console.log(u)
       var neighbors = edges.get(u)
       for (var i=0; i
           var w = neighbors[i]
           if (!marked[w]) {
               dfsVisit(w)
           }
       }
   }
}
graph.dfs()
// 1
// 4
// 3
// 2
// 5
```

广度优先遍历（BFS）

广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS。

BFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层。

步骤：

创建一个队列，并将开始节点放入队列中；

若队列非空，则从队列中取出第一个节点，并检测它是否为目标节点；

若是目标节点，则结束搜寻，并返回结果；

若不是，则将它所有没有被检测过的字节点都加入队列中；

若队列为空，表示图中并没有目标节点，则结束遍历。

```js
Graph.prototype.bfs = function(v) {
   var queue = [], marked = []
   marked[v] = true
   queue.push(v) // 添加到队尾
   while(queue.length > 0) {
       var s = queue.shift() // 从队首移除
       if (this.edges.has(s)) {
           console.log('visited vertex: ', s)
       }
       let neighbors = this.edges.get(s)
       for(let i=0;i
           var w = neighbors[i]
           if (!marked[w]) {
               marked[w] = true
               queue.push(w)
           }
       }
  }
}
graph.bfs(1)
// visited vertex:  1
// visited vertex:  4
// visited vertex:  3
// visited vertex:  2
// visited vertex:  5

```



## 32.异步笔试题   头条

```js
// 今日头条面试题
async function async1() {
   console.log('async1 start')
   await async2()
   console.log('async1 end')
}
async function async2() {
   console.log('async2')
}
console.log('script start')
setTimeout(function () {
   console.log('settimeout')
})
async1()
new Promise(function (resolve) {
   console.log('promise1')
   resolve()
}).then(function () {
   console.log('promise2')
})
console.log('script end')

```

题目的本质，就是考察setTimeout、promise、async await的实现及执行顺序，以及 JS 的事件循环的相关

```js
script start
async1 start
async2
promise1
script end
async1 end
promise2
settimeout
```

## 33.将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})
```

## 34.JS 异步解决方案的发展历程以及优缺点

1)回调函数（callback）

```js
setTimeout(() => {

  // callback 函数体

}, 1000)
```

缺点：回调地狱，不能用 try catch 捕获错误，不能 return

回调地狱的根本问题在于：

缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符；

嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）；

嵌套函数过多的多话，很难处理错误。

```js
ajax('XXX1', () => {
  // callback 函数体
  ajax('XXX2', () => {
    // callback 函数体
   ajax('XXX3', () => {
     // callback 函数体
   })  })
})
```

优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）。

2)Promise

Promise 就是为了解决 callback 的问题而产生的。

Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装。

优点：解决了回调地狱的问题。

```js
ajax('XXX1')
 .then(res => {
   // 操作逻辑
   return ajax('XXX2')
 }).then(res => {
   // 操作逻辑
   return ajax('XXX3')
 }).then(res => {
   // 操作逻辑
 })
```

缺点：无法取消 Promise ，错误需要通过回调函数来捕获。

3)Generator

特点：可以控制函数的执行，可以配合 co 函数库使用。

```js
function *fetch() {
  yield ajax('XXX1', () => {})
  yield ajax('XXX2', () => {})
  yield ajax('XXX3', () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

4)Async/await

async、await 是异步的终极解决方案。

优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题；

缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。

```js
async function test() {
 // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
 // 如果有依赖性的话，其实就是解决回调地狱的例子了
 await fetch('XXX1')
 await fetch('XXX2')
 await fetch('XXX3')
}
```

下面来看一个使用 await 的例子：

```js
let a = 0
let b = async () => {
 a = a + await 10
 console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1
```

对于以上代码你可能会有疑惑，让我来解释下原因：

首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来；

因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码；

同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10。

上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。

## 35.谈谈你对 TCP 三次握手和四次挥手的理解

![e87f34a4ac7ebc4ce81c7afa03b1fa5.png](medias/1550887423585187.png)

## 36.阐述清楚浮动的几种方式（常见问题）

1）父级div定义 height

```text
原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 
优点：简单、代码少、容易掌握 
缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题
```

（2）父级div定义 overflow:hidden

```text
原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 
优点：简单、代码少、浏览器支持好
```

（3） 结尾处加空div标签 clear:both

```text
原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 
优点：简单、代码少、浏览器支持好、不容易出现怪问题
缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好
```

## 37.解释css sprites ，如何使用？

```text
CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，
再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，
background-position可以用数字能精确的定位出背景图片的位置。
CSS Sprites为一些大型的网站节约了带宽，让提高了用户的加载速度和
用户体验，不需要加载更多的图片
```

## 38.什么是ajax? ajax的步骤？

```text
ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页。
如何使用ajax?
第一步，创建xmlhttprequest对象，var xmlhttp =new XMLHttpRequest（);XMLHttpRequest对象用来和服务器交换数据。
var xhttp;
if (window.XMLHttpRequest) {
//现代主流浏览器
xhttp = new XMLHttpRequest();
} else {
// 针对浏览器，比如IE5或IE6
xhttp = new ActiveXObject("Microsoft.XMLHTTP");
}
第二步，使用xmlhttprequest对象的open（）和send（）方法发送资源请求给服务器。
第三步，使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应。
第四步，onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数。
```

## 39.undefined和null的区别

```text
null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，
所以你可以认为它是一个特殊的对象值。
undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。

null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，
和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。
undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，
它是一个预定义的全局变量。没有返回值的函数返回为undefined，
没有实参的形参也是undefined。

javaScript权威指南：
 null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、
 出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺
```

## 40.http和https有何区别？

```text
http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，
加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。
```

## 41.常见的HTTP状态码

```text
2开头 （请求成功）表示成功处理了请求的状态代码。
200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 
201   （已创建）  请求成功并且服务器创建了新的资源。 
202   （已接受）  服务器已接受请求，但尚未处理。 
203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 
204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 
205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206   （部分内容）  服务器成功处理了部分 GET 请求。
3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
400   （错误请求） 服务器不理解请求的语法。 
401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403   （禁止） 服务器拒绝请求。
404   （未找到） 服务器找不到请求的网页。
405   （方法禁用） 禁用请求中指定的方法。 
406   （不接受） 无法使用请求的内容特性响应请求的网页。 
407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408   （请求超时）  服务器等候请求时发生超时。 
409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 
411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 
412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 
415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 
416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417   （未满足期望值） 服务器未满足"期望"请求标头字段的要求。
5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
500   （服务器内部错误）  服务器遇到错误，无法完成请求。 
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。
```

## 42.如何进行网站性能优化

（1）目的： 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。

（2）措施：

```text
——减少HTTP请求数。
——使用缓存。
——脚本的无阻塞加载。
——内联脚本的位置优化等。
——Javascript中的DOM 操作优化、CSS选择符优化。
——图片编码优化，懒加载。
——使用负载均衡方案。
```

## 43.什么是mvvm，mvc？区别？

（1）MVC（Model-View-Controller）

```text
MVC是比较直观的架构模式，用户操作
->View（负责接收用户的输入操作）
->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。MVC使用非常广泛，比如JavaEE中的SSH框架。
```

（2）MVVM（Model-View-ViewModel）

```text
如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。
它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，
通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，
因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应view。
微信小程序前端使用mvvm。
```

## 44.什么是闭包，如何使用它，为什么要使用它？

```text
闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，
只有函数内部的子函数才能读取局部变量，
因此可以把闭包简单理解成“定义在一个函数内部的函数”。

所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

使用闭包的注意点：
· 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
· 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
```

## 45.浏览器是如何渲染页面的？

```text
1.解析HTML文件，创建DOM树。**
自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。
2.解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式。
3.将CSS与DOM合并，构建渲染树（Render Tree）。
4.布局和绘制，重绘（repaint）和重排（reflow）。
```

## 46.从输入url到显示页面，都经历了什么？

```text
1、首先，在浏览器地址栏中输入url。
2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。
4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）
5、握手成功后，浏览器向服务器发送http请求，请求数据包。
6、服务器处理收到的请求，将数据返回至浏览器。
7、浏览器收到HTTP响应。
8、读取页面内容，浏览器渲染，解析html源码。
9、生成Dom树、解析css样式、js交互。
10、客户端和服务器交互。
11、ajax查询。
```

## 47.判断一个字符串中出现次数最多的字符，统计这个次数

```text
var str = 'asdfssaaasasasasaa';
var json = {};
for (var i = 0; i < str.length; i++) {
    if(!json[str.charAt(i)]){
       json[str.charAt(i)] = 1;
    }else{
       json[str.charAt(i)]++;
    }
};
var iMax = 0;var iIndex = '';for(var i in json){
    if(json[i]>iMax){
         iMax = json[i];
         iIndex = i;
    }
}       
console.log('出现次数最多的是:'+iIndex+'出现'+iMax+'次');
```

## 48.讲讲Map和Set

```text
Map的key相比较普通对象来说更为灵活，普通对象的key只能以基础数据类型作为key值，并且所有传入的key值都会被转化成string类型，而Map的key可以是各种数据类型格式。
Set可以讲讲它去重的特性。
```

## 49.浅拷贝和深拷贝的区别

- 浅拷贝：一般指的是把对象的第一层拷贝到一个新对象上去，比如

```
var a = { count: 1, deep: { count: 2 } }
var b = Object.assign({}, a)
// 或者
var b = {...a}
复制代码
```

- 深拷贝：一般需要借助递归实现，如果对象的值还是个对象，要进一步的深入拷贝，完全替换掉每一个复杂类型的引用。

```
var deepCopy = (obj) => {
    var ret = {}
    for (var key in obj) {
        var value = obj[key]
        ret[key] = typeof value === ‘object‘ ? deepCopy(value) : value
    }
    return ret
}
复制代码
```

对于同一个用例来说

```
// 浅拷贝
var a = { count: 1, deep: { count: 2 } }
var b = {...a}

a.deep.count = 5
b.deep.count // 5
复制代码
var a = { count: 1, deep: { count: 2 } }
var b = deepCopy(a)
a.deep.count = 5
b.deep.count // 2
复制代码
```

## 50.介绍下 BFC 及其应用

```
- BFC 即 Block Formatting Contexts (块级格式化上下文),是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。
- 创建 BFC 的方式有：
html 根元素
float 浮动
position (absolute、fixed)
overflow 除了 visible 以外的值 (hidden、auto、scroll)
display 为 inline-block、table-cells、flex
复制代码
```

#### BFC 特性

1）同一个 BFC 下外边距会发生折叠。

如下例子两个盒子之间距离只有100px，这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。

```
<head>
    <style>
        div{
            width: 100px;
            height: 100px;
            margin: 100px;
            border: 1px solid red;
        }
    </style>
</head>
<body>
    <div></div>
    <div></div>
</body>
复制代码
```

即可改成这样

```
<head>
    <style>
        p{
            width: 100px;
            height: 100px;
            margin: 100px;
            border: 1px solid red;
        }
        div{
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div>
        <p></p>
    </div>
    <div>
        <p></p>
    </div>
</body>
复制代码
```

2）BFC 可以包含浮动的元素（清除浮动）

```
<head>
    <style>
        p{
            width: 100px;
            height: 100px;
            background: black;
            float: left;
        }
        div{
            width: 100%;
            border: 1px solid red;
            /* 清除浮动 div可包含浮动的元素*/
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div>
        <p></p>
    </div>
</body>
复制代码
```

3）BFC 可以阻止元素被浮动元素覆盖

下面是一个文字环绕效果

```
<head>
    <style>
        div{
            width: 100px;
            height: 100px;
            background: #4CAF50;
            float: left;
        }
        section{
            width: 300px;
            border: 1px solid red;
            margin: 100px;
        }
    </style>
</head>
<body>
    <section>
        <div>我在左边浮动</div>
        <p>这是一段文字，BFC 即 Block Formatting Contexts (块级格式化上下文),是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>
    </section>
</body>
```

![img](https://user-gold-cdn.xitu.io/2019/12/10/16eeea07bd498090?imageslim)



 ## 51.下面的代码打印什么内容，为什么？

```
var b = 10;
(function b(){
    b = 20;
    console.log(b); 
})();
复制代码
```

正常模式下：

```
var b = 10;
(function b() {
   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
    b = 20;
    console.log(b); // [Function b]
    console.log(window.b); // 10，不是20
})();
```

# webpack

## 52.webpack与grunt、gulp的不同？

三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。

[grunt](https://link.zhihu.com/?target=https%3A//www.gruntjs.net/)和[gulp](https://link.zhihu.com/?target=https%3A//www.gulpjs.com.cn/)是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。

webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。

所以总结一下：

- 从构建思路来说

```
gulp和grunt需要开发者将整个前端构建过程拆分成多个`Task`，并合理控制所有`Task`的调用关系
webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工复制代码
```

- 对于知识背景来说
  gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路



## 53.与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？

同样是基于入口的打包工具还有以下几个主流的：

- webpack
- [rollup](https://link.zhihu.com/?target=https%3A//rollupjs.org/)
- [parcel](https://link.zhihu.com/?target=https%3A//parceljs.org/)

**从应用场景上来看：**

- webpack适用于大型复杂的前端站点构建
- rollup适用于基础库的打包，如vue、react
- parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果

> 由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel



## 54.有哪些常见的Loader？他们是解决什么问题的？

file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件

url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去

source-map-loader：加载额外的 Source Map 文件，以方便断点调试

image-loader：加载并且压缩图片文件

babel-loader：把 ES6 转换成 ES5

css-loader：加载 CSS，支持模块化、压缩、文件导入等特性

style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。

eslint-loader：通过 ESLint 检查 JavaScript 代码



## 55.有哪些常见的Plugin？他们是解决什么问题的？

- define-plugin：定义环境变量
- commons-chunk-plugin：提取公共代码
- uglifyjs-webpack-plugin：通过`UglifyES`压缩`ES6`代码

## 56.Loader和Plugin的不同

**不同的作用**

- **Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析*非JavaScript文件*的能力。
- **Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

**不同的用法**

- **Loader**在`module.rules`中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个`Object`，里面描述了对于什么类型的文件（`test`），使用什么加载(`loader`)和使用的参数（`options`）
- **Plugin**在`plugins`中单独配置。 类型为数组，每一项是一个`plugin`的实例，参数都通过构造函数传入。



## 57.webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果

## 58.是否写过Loader和Plugin？描述一下编写loader或plugin的思路？

Loader像一个"翻译官"把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。

编写Loader时要遵循单一原则，每个Loader只做一种"转义"工作。 每个Loader的拿到的是源文件内容（`source`），可以通过返回值的方式将处理后的内容输出，也可以调用`this.callback()`方法，将内容返回给webpack。 还可以通过 `this.async()`生成一个`callback`函数，再用这个callback将处理后的内容输出出去。 此外`webpack`还为开发者准备了开发loader的工具函数集——`loader-utils`。

相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。



## 59.webpack的热更新是如何做到的？说明其原理？

webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。

![img](medias/1)

图片来自饿了么前端@知乎专栏

首先要知道server端和client端都做了处理工作

1. 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。
2. 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。
3. 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。
4. 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。
5. webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。
6. HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。
7. 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。
8. 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。



## 60.如何利用webpack来优化前端性能？（提高性能和体验）

用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。

- 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的`UglifyJsPlugin`和`ParallelUglifyPlugin`来压缩JS文件， 利用`cssnano`（css-loader?minimize）来压缩css
- 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于`output`参数和各loader的`publicPath`参数来修改资源路径
- 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数`--optimize-minimize`来实现
- 提取公共代码。

## 61.如何提高webpack的构建速度？

多入口情况下，使用`CommonsChunkPlugin`来提取公共代码

通过`externals`配置来提取常用库

利用`DllPlugin`和`DllReferencePlugin`预编译资源模块 通过`DllPlugin`来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过`DllReferencePlugin`将预编译的模块加载进来。

使用`Happypack` 实现多线程加速编译

使用`webpack-uglify-parallel`来提升`uglifyPlugin`的压缩速度。 原理上`webpack-uglify-parallel`采用了多核并行压缩来提升压缩速度

使用`Tree-shaking`和`Scope Hoisting`来剔除多余代码



## 62.怎么配置单页应用？怎么配置多页应用？

单页应用可以理解为webpack的标准模式，直接在`entry`中指定单页应用的入口即可，这里不再赘述

多页应用的话，可以使用webpack的 `AutoWebPlugin`来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：

- 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表
- 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置

## 63.npm打包时需要注意哪些？如何利用webpack来更好的构建？

`Npm`是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去[官网](https://link.zhihu.com/?target=https%3A//docs.npmjs.com/)上进行学习，这里只讲解如何利用webpack来构建。

NPM模块需要注意以下问题：

1. 要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。
2. Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。
3. Npm包大小应该是尽量小（有些仓库会限制包大小）
4. 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。
5. UI组件类的模块应该将依赖的其它资源文件，例如`.css`文件也需要包含在发布的模块里。



## 64.如何在vue项目中实现按需加载？

**Vue UI组件库的按需加载** 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。

不过很多组件库已经提供了现成的解决方案，如Element出品的`babel-plugin-component`和AntDesign出品的`babel-plugin-import` 安装以上插件后，在`.babelrc`配置中或`babel-loader`的参数中进行设置，即可实现组件按需加载了。

```
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
复制代码
```

**单页应用的按需加载** 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。

通过`import(*)`语句来控制加载时机，webpack内置了对于`import(*)`的解析，会将`import(*)`中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到`import(*)`语句时，会去加载Chunk对应生成的文件。`import()`会返回一个Promise对象，所以为了让浏览器支持，需要事先注入`Promise polyfill`

## 65. 如何实现一个简单的 Promise

一个简单的 `Promise` 的粗糙实现，关键点在于

1. 当 `pending` 时， `thenable` 函数由一个队列维护

2. 当状态变为 `resolved(fulfilled)` 时，队列中所有 `thenable` 函数执行

3. 当 `resolved` 时， `thenable` 函数直接执行

   ```js
   class Prom {
     static resolve (value) {
       if (value && value.then) {
         return value 
       }
       return new Prom(resolve => resolve(value))
     }
   
     constructor (fn) {
       this.value = undefined
       this.reason = undefined
       this.status = 'PENDING'
   
       // 维护一个 resolve/pending 的函数队列
       this.resolveFns = []
       this.rejectFns = []
   
       const resolve = (value) => {
         // 注意此处的 setTimeout
         setTimeout(() => {
           this.status = 'RESOLVED'
           this.value = value
           this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) => res(fn(value)))
         })
       }
   
       const reject = (e) => {
         setTimeout(() => {
           this.status = 'REJECTED'
           this.reason = e
           this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) => rej(fn(e)))
         })
       }
   
       fn(resolve, reject)
     }
   
   
     then (fn) {
       if (this.status === 'RESOLVED') {
         const result = fn(this.value)
         // 需要返回一个 Promise
         // 如果状态为 resolved，直接执行
         return Prom.resolve(result)
       }
       if (this.status === 'PENDING') {
         // 也是返回一个 Promise
         return new Prom((resolve, reject) => {
           // 推进队列中，resolved 后统一执行
           this.resolveFns.push({ fn, resolve, reject }) 
         })
       }
     }
   
     catch (fn) {
       if (this.status === 'REJECTED') {
         const result = fn(this.value)
         return Prom.resolve(result)
       }
       if (this.status === 'PENDING') {
         return new Prom((resolve, reject) => {
           this.rejectFns.push({ fn, resolve, reject }) 
         })
       }
     }
   }
   
   Prom.resolve(10).then(o => o * 10).then(o => o + 10).then(o => {
     console.log(o)
   })
   
   return new Prom((resolve, reject) => reject('Error')).catch(e => {
     console.log('Error', e)
   })
   ```

   

## 66. js 中如何实现 bind

```js
Function.prototype.fakeBind = function(obj) {
  return (...args) => this.apply(obj, args)
}
function f (arg) {
  console.log(this.a, arg)
}

// output: 3, 4
f.bind({ a: 3 })(4)

// output: 3, 4
f.fakeBind({ a: 3 })(4)
```





## 67. 什么是 CSRF 攻击

跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

# vue



## 68.vue 中 computed 的原理是什么

要讲清楚，computed原理，首先得讲vue响应式原理，因为computed的实现是基于Watcher对象的。 那么vue的响应式原理是什么呢，众所周知，vue是基于Object.defineProperty实现监听的。在vue初始化数据data和computed数据过程中。会涉及到以下几个对象：

1. Observe对象
2. Dep对象
3. Watch对象 Observe对象是在data执行响应式时候调用，因为computed属性基于响应式属性，所以其不需要创建Observe对象。 Dep对象主要功能是做依赖收集，有个属性维护多个Watch对象，当更新时候循环调用每个Watch执行更新。 Watch对象主要是用于更新，而且是收集的重点对象。

这里谈到computed计算属性，首先要知道，其有两种定义方式，一种是方法，另一种是get，set属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如data的属性vuex的属性。

vue在创建computed属性时候，会循环所有计算属性，每一个计算属性会创建一个watch，并且在通过defineProperty定义监听，在get中，计算属性工作是做依赖收集，在set中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为computed是懒执行，也就是说第一次初始化之后，变不会执行计算，下一次变更执行重新计算是在set中。

另一个补充点是依赖收集的时机，computed收集时机和data一样，是在组件挂载前，但是其收集对象是自己属性对应的watch，而data本身所有数据对应一个watch。

以下附计算属性源码验证说法：

```typescript
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}
```

可以看到，在执行new Watcher之前，会对计算属性做判断，判断其是否为函数，如果不是则取getter。这是因为计算属性有两种定义方式。之后第二步是执行deineCoumputed。这一步只是简单的调用defineProterty我就不贴代码了。

关于计算属性的getter和setter定义如下： 重点关注get的懒加载部分，和Watcher的定义

```typescript
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}
```

## 69.如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗

不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错

- 



# 性能优化



## 70.什么是 Open Graph 协议，用来做什么

Open Graph 协议可以让任何一个网页集成到社交图谱中。例如，facebook就是一种社交图谱(social graph)。 一旦一个网页按照该协议进行集成，这个网页就像是社交图谱的一个节点，例如，你的网页集成了open graph协议， 按照协议加入了网页的标题，描述以及图片信息等等，那么你在facebook中分享这个网页的时候，facebook就会按照 你定义的内容来展示这个网页。

这个协议其实很简单，主要是通过在html中加入一些元数据（meta）标签来实现，例如 在head中加入meta标签，property是以og(open graph)开头, 后面跟着具体属性，content里面是属性的值， 下面这段描述的就是一个类型为 video.movie，标题为 The rock，以及url和图片信息。这个例子就可以当做是 为 https://www.imdb.com/title/tt0117500/ 实现了Open Graph协议、

```text
<html prefix="og: http://ogp.me/ns#">
<head>
<title>The Rock (1996)</title>
<meta property="og:title" content="The Rock" />
<meta property="og:type" content="video.movie" />
<meta property="og:url" content="http://www.imdb.com/title/tt0117500/" />
<meta property="og:image" content="http://ia.media-imdb.com/images/rock.jpg" />
...
</head>
...
</html>
```

结论： 这个协议主要是Facebook提出来的，为了更好的展示用户分享的网页的内容，实现这个协议，有助于SEO优化，告诉google该网页有哪些内容，以及关键词等。

可以快速实现Open Graph协议的工具有： Wordpress的SEO plugin 使用Facebook的Facebook Page功能

## 71.Deno发公告说要把部分ts代码重构为js。 你觉得这是什么原因？

1. node是把包下载到本地，deno是直接引用远程地址
2. 编译时间太长，所以放弃了 ts
3. 还有一些场景不太适合 ts：经常修改原型链的，需要运行时动态添加属性的。

在使用 TypeScript 编写内部代码时，Deno 团队遇到了以下几个现实问题：
在变更文件时，TypeScript 往往需要几分钟的编译时间，这就导致连续编译过程变得非常缓慢；
在创建 Deno 可执行文件以及面向用户的 API 源文件时，TypeScript 结构会引发一系列运行时性能问题；
TypeScript 本身对于 Deno 代码的组织工作毫无帮助，反而增强了代码组织负担。Deno 团队提出的一大现实问题，是 TypeScript 会在两个位置复制相互独立的 Body 类；
https://github.com/denoland/deno/issues/4748
由于 TypeScript 编译器无法帮助开发者生成 d.ts 文件，内部代码与运行时 TypeScript 声明必须以手动方式保持同步；
他们维护着两台 TS 编译器主机：一台用于内部 Deno 代码，另一台用于外部用户代码，但二者的作用其实非常相似。

## 72.Sourcemap是什么？有什么作用？在生产环境怎么用？

`Sourcemap` 本质上是一个信息文件，里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射。 `Sourcemap` 解决了在打包过程中，代码经过压缩，去空格以及 `babel` 编译转化后，由于代码之间差异性过大，造成无法`debug`的问题，简单说 `Sourcemap` 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 `bug` 的位置。因为现在的前端开发都是模块化、组件化的方式，在上线前对 js 和 css 文件进行合并压缩容易造成混淆。如果对这样的线上代码进行调试，肯定不切实际，`sourceMap` 的作用就是能够让浏览器的调试面版将生成后的代码映射到源码文件当中，开发者可以在源码文件中 debug，这样就会让程序员调试轻松、简单很多。

`Sourcemap` 的种类有很多， 在生产环境下可以用`process.env `判断一下。  `webpack`中可以在`devtool`中设置, 在开发环境中可以配置`devtool`为`cheap-module-source-map`，方便调试。生产环境下建议采用`none`的方式，这样做不暴露源代码。或者是`nosources-source-map` 的方式，既可以定位源代码位置，又不暴露源代码。

## 73.谈谈对$nextTick的理解及使用场景

对nextTick的理解

- **Vue的视图更新是通过数据驱动的，当数据发生改变的时候，将当前的数据更改保存在队列中，然后异步的更新视图**
- **由于Vue的视图更新是异步的，所以我们在修改完成数据之后，不一定当前的View已经发生改变，于是就有了nextTick**
- **nextTick是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。**

nextTick的使用场景

- **如果要在created()钩子函数中进行的DOM操作，由于created()钩子函数中还未对DOM进行任何渲染，所以无法直接操作，需要通过`$nextTick()`来完成。在created()钩子函数中进行的DOM操作，不使用`$nextTick()`会报错**
- **更新数据后，想要使用js对新的视图进行操作时**
- **在使用某些第三方插件时 ，这些插件需要dom动态变化后重新应用该插件，这时候就需要使用$nextTick()来重新应用插件的方法**

nextTick的使用方法

1. 使用

   ```
   Vue.nextTick
   ```

   全局方法

   

   ```vue
   // 修改数据
   vm.msg = 'Hello'
   // DOM 还没有更新
   Vue.nextTick(function () {
      // DOM 更新了执行的回调
   })
   
   // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
   Vue.nextTick() .then(function () {
         // DOM 更新了
   })
   ```

2. 在Vue实例对象中，使用

   ```
   this.$nextTick
   ```

   方法

   

   ```vue
   new Vue({
        // ...
             methods: {
            // ...
               example () {
               // 修改数据
              this.message = 'changed'
              // DOM 还没有更新
             this.$nextTick(function () {
             // DOM 现在更新了
             // `this` 绑定到当前实例
             this.doSomethingElse()
         })
       }
     }
   })
   ```

# VUE

## 74,Vue中的双向数据绑定是如何实现的

**Vue的双向数据绑定是通过数据劫持结合发布者订阅者模式来实现的**
 要实现这种双向数据绑定，必要的条件有：

> 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
>  2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
>  3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
>  4、MVVM入口函数，整合以上三者

![img](medias/webp)

**个人理解：在new Vue的时候，在Observer中通过Object.defineProperty()达到数据劫持，代理所有数据的getter和setter属性，在每次触发setter的时候，都会通过Dep来通知Watcher，Watcher作为Observer数据监听器与Compile模板解析器之间的桥梁，当Observer监听到数据发生改变的时候，通过Updater来通知Compile更新视图**
 **而Compile通过Watcher订阅对应数据，绑定更新函数，通过Dep来添加订阅者，达到双向绑定**

## 75.详述虚拟DOM中的diff算法

1. **首先要先讲一下虚拟DOM是如何实现的**
    **虚拟DOM是通过js语法来在内存中维护一个通过数据解构描述出来的一个模拟DOM树，当数据发生改变的时候，会先对虚拟DOM进行模拟修改，然后在通过新的虚拟DOM树与旧的虚拟DOM树来对比，而这个对比就是通过diff算法来进行的**
    **虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象）**

2. 接着，来看一下diff算法是如何进行比对的

   正常的diff算法，是通过层层对比，单单对比来进行的，对于我们的前端性能来说，很明显是不可以这样实现的。

   ![img](https:////upload-images.jianshu.io/upload_images/18087456-1b629b840eee296d.png?imageMogr2/auto-orient/strip|imageView2/2/w/736/format/webp)

   前端的虚拟DOM对比

**所以，前端的diff算法是通过以下步骤来实现的**

> 步骤一：用JS对象模拟DOM树
>  步骤二：比较两棵虚拟DOM树的差异
>  步骤三：把差异应用到真正的DOM树上

**同时维护新旧两棵虚拟DOM树，当数据发生改变的时候，开始执行对比**
 **首先对根元素进行对比，如果根元素发生改变就直接对根元素替换**
 **如果根元素没有发生改变的话，再对下一层元素进行对比，如果对比发现元素发生删除，就执行删除，发现元素被替换就执行替换，发现添加了新的元素就执行添加**
 **对比的同时，会通过key值来判断元素是否发生改变，判断元素是仅仅位置发生改变还是需要整个替换或删除**
 **如果不是元素发生改变的话，再对内容进行对比，如果是内容发生改变的话，就直接修改内容**
 **其实就是进行逐层对比，再通过不同的对比来判断执行不同的操作**

## 76.Vue提供了几种脚手架模板

`webpack` - 一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。

`webpack-simple` - 一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。

`browserify` - 一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。

`browserify-simple` - 一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。

`simple` - 一个最简单的单页应用模板。

`pwa` - 一个集成pwa环境的webapp的模板

## 77.实现数据绑定的做法有大致有几种：

**发布者-订阅者模式**
 一般通过sub,pub的方式实现数据和视图的绑定监听，
 更新数据方式通常做法是 `vm.set('property', value)`。

这种方式现在毕竟太low了，我们更希望通过vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式。

**脏值检查**

angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，
 最简单的方式就是通过 setInterval() 定时轮询检测数据变动，
 angular只有在指定的事件触发时进入脏值检测，大致如下：

> 1、DOM事件，譬如用户输入文本，点击按钮等。( `ng-click` )
>  2、XHR响应事件 ( `$http` )
>  3、浏览器Location变更事件 ( `$location` )
>  4、Timer事件( `$timeout` , `$interval` )
>  5、执行 `$digest()` 或`$apply()`

**数据劫持**
 vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，
 通过`Object.defineProperty()`来劫持各个属性的`setter，getter`，
 在数据变动时发布消息给订阅者，触发相应的监听回调。

# http

## 78.http缓存机制，浏览器缓存到底是什么？

所谓的http缓存，就是浏览器自己给你的一个功能，一个缓存数据库，夹在服务端和客户端中间，你只需要设置一些参数即可实现 缓存/不缓存/时效内缓存/时效外缓存等（默认存在缓存）
浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：

（1）浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。

（2）如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（3）如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。

## 79.浏览器 cookie 和 session 的认识

session 是基于 cookie 实现的。cookie 保存在客户端浏览器中，而 session 保存在服务器上。cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

cookie 和 session 的区别：存在的位置：cookie 存在于客户端，临时文件夹中；session 存在于服务器的内存中，一个 session 域对象为一个用户浏览器服务安全性cookie 是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；session 存放于服务器的内存中，所以安全性好生命周期(以 20 分钟为例)cookie 的生命周期是累计的，从创建时，就开始计时，20 分钟后 cookie 生命周期结束；session 的生命周期是间隔的，从创建时，开始计时如在 20 分钟，没有访问 session，那么 session 生命周期被销毁。但是，如果在 20 分钟内（如在第 19 分钟时）访问过 session，那么，将重新计算 session 的生命周期。关机会造成 session 生命周期的结束，但是对 cookie 没有影响访问范围cookie 为多个用户浏览器共享；session 为一个用户浏览器独享

# Vue

## 80.开发环境和生产环境各自做什么

一般开发环境就是有很多调试代码，和调试信息输出的环境。运行环境把调试部分都删除，或屏蔽了，速度会更快。开发环境：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。生产环境：是值正式提供对外服务的，一般会关掉错误报告，打开错误日志。

## 81.vue组件之间的通信方式？

- 组件通信方式大体有以下8种：

  - props
  - $emit/$on
  - $children/$parent
  - $attrs/$listeners
  - ref
  - $root
  - eventbus
  - vuex

- 根据组件之间关系讨论组件通信最为清晰有效

  - 父子组件

    ```
    props
    $emit/$on
    $parent/$children
    ref
    $attrs/$listeners
    ```
  
  - 兄弟组件
  
    ```js
    $parent
    eventbus
    vuex
    ```
  
    
  
  - 跨层级关系
  
    ```js
    provide/inject
    $root
    eventbus
    vuex
    ```
  
    

## 82.简单说一说你对vuex的理解

  - 思路分析：3w1h（what why where how）
    - 首先给vuex下一个定义
    - vuex解决了哪些问题，解读理念
    - 什么时候我们需要veux
    - 你的具体用法
    - 简述原理，提升层级
  - 回答范例：
    - vuex是vue专用的状态管理库，它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性
    - vuex主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会是程序逻辑变得复杂。vuex通过吧组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简介的单向数据流动，我们的代码将变得更结构化且易维护
    - vuex并非必须的，它帮助我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用vuex的必要。一个简单的store模式就足够了。反之，vuex将会成为自然而然的选择。引用Redux的作者Dan Abramov的话说就是：Flux构架就像眼镜：您会知道什么时候需要它
    - 我在使用vuex过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入state对象中，它本身是一棵状态树，组件中使用store实例的state访问这些状态；然后有配套的mutation方法修改这些状态，并且只能用mutation修改状态，在组件中调用commit方法提交mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写action，执行结束如果有状态修改仍然需要提交mutation，组件中调用这些action使用dispatch方法派发。最后是模块化，通过modules选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置namespace，那么在提交mutation和派发action时还需要额外的命名空间前缀
    - vuex在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了vue的数据响应化特性实现的，它会利用vue将state作为data对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染

# 工程化

## 83.如果让你来制作一个访问量很高的大型网站，你会如何来管理所有css、js文件、图片？

（1）遵循自定的一套CSS，JS和图片文件和文件夹命名规范

（2）依托采用的前端工程化工具，依照工具脚手架规范 (gulp, webpack, grunt, yeoman)

（3）依据采用的框架规范（Vue, React, jQuery）

## 84.如果没有框架、怎么搭建你的项目,应用原生JS自己尝试搭建一个MVC架构

(1) 基本模块

common：公共的一组件，下面的各模块都会用到

config：配置模块，解决框架的配置问题

startup：启动模块，解决框架和Servlet如何进行整合的问题

plugin：插件模块，插件机制的实现，提供IPlugin的抽象实现

routing：路由模块，解决请求路径的解析问题，提供了IRoute的抽象实现和基本实现

controller：控制器模块，解决的是如何产生控制器

model：视图模型模块，解决的是如何绑定方法的参数

action：action模块，解决的是如何调用方法以及方法返回的结果，提供了IActionResult的抽象实现和基本实现

view：视图模块，解决的是各种视图引擎和框架的适配

filter：过滤器模块，解决是执行Action，返回IActionResult前后的AOP功能，提供了IFilter的抽象实现以及基本实现

2）扩展模块

filters：一些IFilter的实现

results：一些IActionResult的实现

routes：一些IRoute的实现

plugins：一些IPlugin的实现

## 85.在选择框架的时候要从哪方面入手

影响团队技术选型有很多因素，如技术组成，新技术，新框架，语言及发布等。为了更好的考量不同的因素，需要列出重要的象限，如开发效率、团队喜好，依次来决定哪个框架更适合当前的团队和项目。上线时间影响框架选择，不要盲目替换现有框架。

（1）jQuery

项目功能比较简单。并不需要做成一个单页面应用，就不需要 MV* 框架。项目是一个遗留系统。与其使用其他框架来替换，不如留着以后重写项目。

（2）AngularJS

当我们在制作一个应用，它对性能要求不是很高的时候，那么我们应该选择开发速度更快的技术栈AngularJS，她拥有混合开发能力的ionic框架。对于复杂的前端应用来说，基于 Angular.js 应用的运行效率，仍然有大量地改进空间。Angular2需要学习新的语言，需慎重选择。

（3）React

选择React有两个原因，一是通过Virtual DOM提高运行效率，二是通过组件化提高开发效率。大型项目首选。选择 React 还有一个原因是：React Native、React VR 等等，可以让 React 运行在不同的平台之上。我们还能通过 React 轻松编写出原生应用，还有 VR 应用。

令人遗憾的是 React 只是一个 View 层，它是为了优化 DOM 的操作而诞生的。为了完成一个完整的应用，我们还需要路由库、执行单向流库、web API 调用库、测试库、依赖管理库等等，为了完整搭建出一个完整的 React 项目，我们还需要做大量的额外工作。

（4）Vue.js

对于使用 Vue.js 的开发者来说，我们仍然可以使用 熟悉的 HTML 和 CSS 来编写代码。并且，Vue.js 也使用了 Virtual DOM、Reactive 及组件化的思想，可以让我们集中精力于编写应用，而不是应用的性能。

对于没有 Angular 和 React 经验的团队，并且规模不大的前端项目来说，Vue.js 是一个非常好的选择。

# vue

## 86.说一下Vue的生命周期

`beforeCreate`是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。

`created`在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。

`beforeMount`发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。

`mounted`在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。

`beforeUpdate`发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。

`updated`发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

`beforeDestroy`发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。

`destroyed`发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

 ## 87.说一下v-model的原理

`v-model`本质就是一个语法糖，可以看成是`value + input`方法的语法糖。 可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

## 88.Vue模版编译原理知道吗，能简单说一下吗？

简单说，Vue的编译过程就是将`template`转化为`render`函数的过程。会经历以下阶段：

- 生成AST树
- 优化
- codegen

首先解析模版，生成`AST语法树`(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以`跳过对它们的比对`，对运行时的模板起到很大的优化作用。

编译的最后一步是将优化后的AST树转换为可执行的代码

## 89.keep-alive了解吗,只要用来做什么

`keep-alive`可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

常用的两个属性`include/exclude`，允许组件有条件的进行缓存。

两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。

keep-alive的中还运用了`LRU(Least Recently Used)`算法。

 ## 90.Vue中组件生命周期调用顺序说一下

组件的调用顺序都是`先父后子`,渲染完成的顺序是`先子后父`。

组件的销毁操作是`先父后子`，销毁完成的顺序是`先子后父`。

加载渲染过程

```
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted
```

子组件更新过程

```
父beforeUpdate->子beforeUpdate->子updated->父updated
```

父组件更新过程

```
父 beforeUpdate -> 父 updated
```

销毁过程

```
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

## 91.SSR了解吗

SSR也就是服务端渲染，`也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端`。

SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持`beforeCreate`和`created`两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。

## 92.你都做过哪些Vue的性能优化

编码阶段

尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher

v-if和v-for不能连用

如果需要使用v-for给每项元素绑定事件时使用事件代理

SPA 页面采用keep-alive缓存组件

在更多的情况下，使用v-if替代v-show

key保证唯一

使用路由懒加载、异步组件

防抖、节流

第三方模块按需导入

长列表滚动到可视区域动态加载

图片懒加载

SEO优化

- 预渲染
- 服务端渲染SSR

打包优化

- 压缩代码
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包happypack
- splitChunks抽离公共文件
- sourceMap优化

## 93.hash路由和history路由实现原理说一下

`location.hash`的值实际就是URL中`#`后面的东西。

history实际采用了HTML5中提供的API来实现，主要有`history.pushState()`和`history.replaceState()`。

## 94.谈一下webpack中分包如何实现的？

使用**html-webpack-externals-plugin**指定引入包CDN

```js
new HtmlWebpackExternalsPlugin({
  externals: [
    {
      module: 'jquery',
      entry: '//unpkg.com/jquery@3.2.1/dist/jquery.min.js',
      global: 'jQuery',
    },
    {
      module: 'react',
      entry: '//unpkg.com/react@16/umd/react.production.min.js',
      global: 'React',
    },
  ],
})

```

# typescript

## 95.列出使用Typescript的一些优点

- 它提供了可选静态类型的优点。在这里，Typescript提供了可以添加到变量、函数、属性等的类型。
- Typescript能够编译出一个能在所有浏览器上运行的JavaScript版本。
- TypeScript总是在编译时强调错误，而JavaScript在运行时指出错误。
- TypeScript支持强类型或静态类型，而这不是在JavaScript中。
- 它有助于代码结构。
- 它使用基于类的面向对象编程。
- 它提供了优秀的工具支持和智能感知，后者在添加代码时提供活动提示。
- 它通过定义模块来定义名称空间概念。

## 96.Typescript的缺点是什么?

- TypeScript需要很长时间来编译代码。
- TypeScript不支持抽象类。
- 如果我们在浏览器中运行TypeScript应用程序，需要一个编译步骤将TypeScript转换成JavaScript。
- Web开发人员使用了几十年的JavaScript，而TypeScript不是都是新东西。
- 要使用任何第三方库，必须使用定义文件。并不是所有第三方库都有可用的定义文件。
- 类型定义文件的质量是一个问题，即如何确保定义是正确的?

## 97.JavaScript不支持函数重载，但TypeScript是否支持函数重载？

是的，TypeScript支持函数重载。但是它的实现很奇怪，当我们在TypeScript中执行函数重载时，我们只能实现一个带有多个签名的函数。

```
//带有字符串类型参数的函数  
function add(a:string, b:string): string;    
  
//带有数字类型参数的函数
function add(a:number, b:number): number;    
  
//函数定义
function add(a: any, b:any): any {    
    return a + b;    
}    
```

在上面的例子中，前两行是函数重载声明。它有两次重载，第一个签名的参数类型为string，而第二个签名的参数类型为number。第三个函数包含实际实现并具有any类型的参数。任何数据类型都可以接受任何类型的数据。然后，实现检查所提供参数的类型，并根据供应商参数类型执行不同的代码段。

## 98.call() 和 apply() 的区别和作用？

①apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。
 如：function.apply(this,[1,2,3])；
 ②call()的第一个参数是上下文，后续是实例传入的参数序列。
 如：function.call(this,1,2,3)；

## 99.线程与进程的区别

①一个程序至少有一个进程,一个进程至少有一个线程。
②线程的划分尺度小于进程，使得多线程程序的并发性高。
③另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
④线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
⑤从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

## 100.浏览器是怎样解析CSS选择器的？

样式系统从关键选择器开始匹配，然后从右左移查找规则选择器的祖先元素。浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。Firefox 称这种查找方式为 keyselector(关键字查询)，所谓的关键字就是样式规则中最后(最右边)的规则。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。

> ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。

单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）

双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。
 想让插入的内容出现在其它内容前，使用::before，否者，使用::after

在代码顺序上，::after生成的内容也比::before生成的内容靠后。
 如果按堆栈视角，::after生成的内容会在::before生成的内容之上

## 101.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）

多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms















