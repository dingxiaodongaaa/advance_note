<!--
 * @Descripttion: 
 * @version: 
 * @Author: dingxd
 * @Date: 2020-05-24 08:22:16
 * @LastEditors: dingxd
 * @LastEditTime: 2020-05-24 12:11:25
--> 
#### 为什么要学习函数式编程

- 函数式编程是随着React的流行受到越来越多的关注
- Vue 3也开始拥抱函数式编程
- 函数式编程可以抛弃this
- 打包过程中可以更好的利用tree shaking过滤无用代码
- 方便测试，方便并行处理
- 有很多库可以帮助我们进行函数式开发：lodash、undersore、ramda

#### 什么是函数式编程

函数式编程（Functional Programming，FP），FP是编程范式之一，我们常说的编程范式还有面向对象编程、面向过程编程。

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系

- 函数式编程的思维方式：把现实世界的事物和事件之间的联系抽象到程序世界（对运算过程进行抽象）

    - 程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数。
    
    - x -> f(联系、映射) -> y, y = f(x)

    - **函数式编程中的函数指的不是程序中的函数（方法）**，而是数学中的函数即映射关系，例如：**y = sin(x)**，x和y的关系

    - **相同的输入始终要得到相同的输出**（纯函数）

    - 函数式编程用来描述数据（函数）之间的映射

#### 前置知识

- 函数是一等公民
- 高阶函数
- 闭包

#### 函数是一等公民

[MDN First-class Function](https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function)

- 函数可以存储在变量中
- 函数作为参数
- 函数作为返回值

在Javascript中**函数就是一个普通的对象**（可以通过`new Function()`），我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数或者返回值，甚至我们可以在程序运行的时候，通过`new Function('alert(1)')`来构造一个新的函数。

- 把函数赋值给变量

```javascript
// 把函数赋值给变量
let fn = function () {
    console.log('hello First-class Function')
}

// 一个示例
const BlogConstroller = {
    index (posts) { return Views.index(posts) },
    show (posts) { return Views.show(posts) },
    create (attrs) { return Db.create(attrs) },
    update (posts, attrs) { return Db.update(posts, attrs) },
    destroy (posts) { return Db.destroy(posts) },
}

// 优化
const BlogConstroller = {
    index: Views.index,
    show: Views.show,
    create: Db.create,
    update: Db.update,
    destroy: Db.destroy,
}
```

#### 高阶函数

- 高阶函数（Higher-order function）

    - 可以把函数作为参数传递给另一个函数
    - 可以把函数作为另一个函数的返回结果

- 函数作为参数

```javascript
// forEach
function forEach(Array, fn){
    for(let i = 0; i < Array.length; i++){
        fn(Array[i])
    }
}
const arr = [1, 2, 3, 4, 5, 6, 7, 8]
forEach(arr, function(item){
    console.log(item)
})

// filter
function filter(Array, fn){
    let arr = []
    for(let i = 0; i < Array.length; i++){
        if(fn(Array[i])){
            arr.push(Array[i])
        }
    }
    return arr
}
const arr = [1, 2, 3, 4, 5, 6, 7, 8]
let result = filter(arr, function(item){
    return item % 2 === 0
})
console.log(result)
```

- 函数作为返回值

```javascript
function makeFn () {
    const msg = "woailili"
    return function(){
        console.log(msg)
    }
}

// const fn = makeFn()
// fn()
makeFn()()

//once
function once (fn) {
    let done = false
    return function () {
        if(!done){
            done = true
            return fn.apply(this, arguments)
        }
    }
}
const pay = once(function (money) {
    console.log(`支付${money}元`)
})
pay(1)
pay(1)
pay(1)
// once函数是一个高阶函数，它接收一个函数作为参数，作用就是返回一个函数，返回的这个函数不管执行几次，它只会调用一次这个参数函数。
// 一句话说就是，生成一个只会执行一次的函数
```

#### 高阶函数的意思

函数式编程的核心思想，函数式编程的核心是将运算过程抽象成函数，然后可以在任何使用的情况下复用这些函数。调用的时候可以不去关心它实现的细节，只需要了解自己的目标就可以。

- 抽象可以帮我们屏蔽细节，只需要关注目标
- 高阶函数是用来抽象通用的问题，代码简洁
- 灵活的函数调用

想前面封装的forEach函数，它的作用就是循环一个数组，并按照传入的函数取处理循环的每一个数组元素。我们在调用的时候不需要去关系循环的细节，只需要关系想要对数组进行怎样的处理就可以了。

#### 常用的高阶函数

- forEach
- map
- filter
- every
- some
- find/findIndex
- reduce
- sort
- ……

**map**

```javascript
// map
const map = (Array, fn) => {
    let arr = []
    for(let value of Array){
        arr.push(fn(value))
    }
    return arr
}

const arr = [1, 2, 3, 4, 5, 6, 7, 8]
let result = map(arr, item => item * 2)
console.log(result)
```

```javascript
// every
const every = (Array, fn) => {
    for(let value of Array){
        if(!fn(value)){
            return false
        }
    }
    return true
}

const arr = [1, 2, 3, 4, 5, 6, 7, 8]
let result = every(arr, item => item > 2)
console.log(result)
```

```javascript
// some
const some = (Array, fn) => {
    for(let value of Array){
        if(fn(value)){
            return true
        }
    }
    return false
}

const arr = [1, 2, 3, 4, 5, 6, 7, 8]
let result = some(arr, item => item > 100)
console.log(result)
```

#### 闭包

- 闭包（Closure）：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。

    - 可以在另一个作用域中调用一个函数(1)的内部函数(2)并访问到该函数(1)的作用域中的成员。

    - 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完之后从执行栈上移除，**但是堆上的作用域成员因为被外部引用不能释放**，因此当内部函数调用的时候依然可以访问到外部函数的成员。

```javascript
function makeFn () {
    const msg = "woailili"
    return function(){
        console.log(msg)
    }
}

// const fn = makeFn()
// fn()
makeFn()()

//once
function once (fn) {
    let done = false
    return function () {
        if(!done){
            done = true
            return fn.apply(this, arguments)
        }
    }
}
const pay = once(function (money) {
    console.log(`支付${money}元`)
})
pay(1)
pay(1)
pay(1)
```

#### 闭包案例

```javascript
const makePower = function (power) {
    return function(number){
        return Math.pow(number, power)
    }
}
// 求平方的函数
const power2 = makePower(2)
// 求立方的函数
const power3 = makePower(3)
console.log(power2(2))
console.log(power3(2))
```