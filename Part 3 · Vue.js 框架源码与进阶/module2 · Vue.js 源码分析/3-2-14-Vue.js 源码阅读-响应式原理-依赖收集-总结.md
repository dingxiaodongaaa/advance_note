# 响应式原理-依赖收集-总结

本篇将通过调试的过程讲解 Vue 响应式处理中收集依赖的整个过程。

通过前面的了解，收集依赖其实就是通过data 中的属性对应的 dep 对象，收集当前对应的 Component 对象对应的 watcher。具体就是将组件对应的 watcher 对象添加到属性对应的 dep 的 subs 数组中。

也就是说 watcher 是基于一个组件的，当一个组件中多次用到了某一个属性，那么也只需要收集一次依赖就够了，当属性发生变化的时候，去更新整个组件。

Vue2.0 开始更改每一个组件作为一个对应一个 watcher 对象。这种做法其实就是牺牲了一些 cpu 的开销来减少数据响应式对内存的占用。

假如说将每一个使用这个属性的 DOM 节点作为一个依赖，当这个属性发生变化的时候就需要去通知所有的依赖，让 DOM 进行更新。这种细粒度的依赖追踪关系，会大大增加依赖追踪消耗的内存。因此，从 Vue2.0 开始，它引入了虚拟 DOM ，将粒度调整为中等力度，即一个状态所绑定的依赖不再是具体的 DOM 节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。这可以大大降低依赖数量，从而降低依赖追踪所消耗的 内存。

收集依赖是从 watcher 的 get 中开始的，所以调试的断点应该从这里开始。