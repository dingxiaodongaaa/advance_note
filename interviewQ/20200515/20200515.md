## 20200515面试题

### 阅读下面代码，分析执行结果，并说明具体原因。

```javascript
var num = 20;

const obj = {
    num: 10,
    func: (num) => {
        this.num += 5;
        console.log(this.num);

        num += 5;
        console.log(num);
        var num = 30;

        return function () {
            this.num += 4;
            console.log(this.num);

            num += 10;
            console.log(num);
        };
    },
};

obj.func(40)();

```

### 答案

- 浏览器环境下答案是25 45 29 40
- node 环境下答案是NaN 45 NaN 40

### 解析

#### 一、浏览器环境

在浏览器下，`obj.func`它是一个箭头函数，箭头函数不会影响内部的`this`执行，所以当我们调用`obj.func(40)`的时候，`func`这个函数内部的`this`就会执行obj.func(40)的执行上下文，所以这个时候的`this`就是Window，获取`this`.num就相当于获取`Window.num`。所以第一个打印的是25。

然后，在函数里面执行`num += 5`,这里的``num``的执行上下文就是这个函数作用域，这里面的`num`既是这个函数的参数即40，所以第二个打印是45。

接下来调用的`obj.func(40)`这个函数会返回一个函数，并将这个函数作为一个匿名函数在全局直接调用，又因为这个函数不是箭头函数，而是一个普通的函数，所以这个函数的`this`一定是指向调用这个函数的对象，所以这个函数此时在全局调用，它的`this`就是指向的全局`window`对象，所以在第三个打印的是29。

接下来获取了这个函数声明的上下文中的变量`num` 在执行`obj.func(40)()`的时候，就行形成闭包，在`obj.func`中声明的`var num = 30`这个变量回作为返回的函数执行时候的依赖依旧保留在内存中，当调用这个函数的时候可以获取到，所以最后一个但因的是40。

**标准答案**

在浏览器下，obj.func他是一个箭头函数，箭头函数不会影响背部的`this`指向，执行的时候内部的`this`指向的必然是全局对象也就是`window`，所以里面的`this`.`num`其实就是`window`下的`num`，所以结果是25。

`obj.func`执行的时候带入了实参`num=40`，函数内的`var num` 虽然有变量提升，但是提升的只是声明，在它声明之前，形参内已经声明过了`num`，所以这个声明就不会生效，那`num`当中自然保留实参传过来的40，所以打印出的`num`是45（这个点是很多人容易出错的地方，尤其需要注意）

`obj.func`执行后的返回值是个匿名函数，这个函数内的`this`跟它的执行体有关，这个函数的执行体依然是`window`。所以里面的`this.num`还是`window`下的`num`，打印结果是29。

`obj.func`的返回值匿名函数内没有声明变量`num`，所以向它的父级作用域查找，此时父级作用域下的`num`被赋值为30，所以打印结果是40。

#### 二、Node.js环境

在`node`环境中和浏览器中的区别就是，`node`全局上下文中的`this`是一个空对象，在第一个中，空对象的某一个属性肯定是`undefined`加一个数字自然是`NaN`。第三个打印同理。

第二个和第四个打印就跟浏览器没什么区别了。